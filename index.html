<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ИГЭУ САПР</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="css/flaticon.css">
    <script src="js/jquery-2.1.4.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/svg.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/three/controls/TrackballControls.js"></script>
    <script src="js/ThreeCSG.js"></script>
</head>
<body>
<!-- Modal -->
<div class="modal fade" id="cubeModal">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                <h4 class="modal-title">Создать паралепипед</h4>
            </div>
            <div class="modal-body">
                <div class="form-horizontal">
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Ширина</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control width" name="width">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Высота</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control height" name="height">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Глубина</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control depth" name="depth">
                        </div>
                    </div>
                </div>
                <div class="clearfix"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary accept">Создать</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="cylinderModal">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                <h4 class="modal-title">Создать цилиндр</h4>
            </div>
            <div class="modal-body">
                <div class="form-horizontal">
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Высота</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control width" name="width">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Радиус</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control radius" name="radius1">
                        </div>
                    </div>
                </div>
                <div class="clearfix"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary accept">Создать</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="coneModal">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                <h4 class="modal-title">Создать конус</h4>
            </div>
            <div class="modal-body">
                <div class="form-horizontal">
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Высота</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control width" name="width">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Радиус 1</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control radius1" name="radius1">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Радиус 2</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control radius2" name="radius2">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary accept">Создать</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="sphereModal">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
                <h4 class="modal-title">Создать сферу</h4>
            </div>
            <div class="modal-body">
                <div class="form-horizontal">
                    <div class="form-group">
                        <label class="col-sm-2 control-label">Радиус</label>
                        <div class="col-sm-10">
                            <input placeholder="0" class="form-control radius" name="radius">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary accept">Создать</button>
            </div>
        </div>
    </div>
</div>

<nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-brand" href="#">ИГЭУ САПР</a>
        </div>
        <p class="navbar-text navbar-right">© Игорь Майоров</p>
    </div>
</nav>
<div class="container">
    <div class="row">
        <button data-toggle="modal" data-target="#cubeModal" class="btn btn-default btn-lg" type="submit"><i class="flaticon-rectangular"></i></button>
        <button data-toggle="modal" data-target="#cylinderModal" class="btn btn-default btn-lg" type="submit"><i class="flaticon-cylinder"></i></button>
        <button data-toggle="modal" data-target="#coneModal" class="btn btn-default btn-lg" type="submit"><i class="flaticon-cone"></i></button>
        <button data-toggle="modal" data-target="#sphereModal" class="btn btn-default btn-lg" type="submit"><i class="flaticon-sphere"></i></button>
        <div class="arrows" style="display: none">
            <button direction="left" class="btn btn-info btn-lg"><i class="glyphicon glyphicon-arrow-left"></i></button>
            <button direction="right" class="btn btn-info btn-lg"><i class="glyphicon glyphicon-arrow-right"></i></button>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6">
            <div class="row" id="drawing"></div>
        </div>
        <div class="col-md-6">
            <div class="row" id="modeling"></div>
        </div>
    </div>

</div>
<script>
    var camera,
        controls,
        scene,
        renderer,
        raycaster,
        mouse,
        draw,
        colors = ['#fff', '#000'], // Зададим параметры
        borderWidth = 2,
        axisPadding = 7,
        windowWidth = $('#drawing').width(),
        selected = false;

    var objects = { // Массив, в котором будет хранится вся инфа о имеющихся элементах на странице. Есть идея все это сеарилизировать на сервере
        d2: [],
        d3: [],
        values: [],
        totalWidth: 0,
        segments: 256,
        addCube: function (values, direction) {
            this.moveObjects(values.width, direction); // Двигаем элементы в сторону

            // 2D
            var group = draw.group();
            group.add(draw.rect(values.width, values.height).fill({
                color: colors[1]
            }));
            group.add(draw.rect(values.width - borderWidth * 2, values.height - borderWidth * 2).colorIt().move(borderWidth, borderWidth));
            group.placeIt(this.totalWidth, direction);

            // 3D
            var object = new THREE.Mesh(new THREE.BoxGeometry(values.height, values.width, values.depth), new THREE.MeshPhongMaterial({
                color: 0xF0F0F0,
                shading: THREE.FlatShading
            }));
            object.translateX(this.totalWidth / 2 * direction);
            object.rotation.z = -(90 * Math.PI / 180);
            scene.add(object);
            this.addToArray(group, object, values, direction);
        },

        addSphere: function (values, direction) {
            values.height = values.radius * 2;
            values.width = values.radius * 2;
            this.moveObjects(values.width, direction); // Двигаем элементы в сторону

            // 2D
            var group = draw.group();
            group.add(draw.circle(values.radius * 2).fill({
                color: colors[1]
            }));
            group.add(draw.circle(values.radius * 2 - borderWidth * 2).colorIt().move(borderWidth, borderWidth));

            //Axis rendering
            group.add(draw.line(values.width / 2, -axisPadding, values.width / 2, values.width + axisPadding).dashIt(values.width));
            group.add(draw.line(-axisPadding, values.width / 2, values.width + axisPadding, values.width / 2).dashIt(values.width));
            group.placeIt(this.totalWidth, direction, true, true);

            // 3D
            var object = new THREE.Mesh(new THREE.SphereGeometry(values.radius, this.segments, this.segments), new THREE.MeshPhongMaterial({
                color: 0xF0F0F0,
                shading: THREE.FlatShading
            }));
            object.translateX(this.totalWidth / 2 * direction);
            object.rotation.z = -(90 * Math.PI / 180);
            scene.add(object);

            this.addToArray(group, object, values);
        },

        addCylinder: function (values, direction) {
            values.radius2 = values.radius1;
            values.height = values.radius2 * 2;
            this.moveObjects(values.width, direction); // Двигаем элементы в сторону

            // 2D
            var group = draw.group();
            group.add(draw.rect(values.width, values.height).fill({
                color: colors[1]
            }));
            group.add(draw.rect(values.width - borderWidth * 2, values.height - borderWidth * 2).colorIt().move(borderWidth, borderWidth));

            //Axis rendering
            group.add(draw.line(-axisPadding, values.height / 2, values.width + axisPadding, values.height / 2).dashIt(values.width));
            group.placeIt(this.totalWidth, direction, true);

            // 3D
            var object = new THREE.Mesh(new THREE.CylinderGeometry(values.radius1, values.radius2, values.width, this.segments), new THREE.MeshPhongMaterial({
                color: 0xF0F0F0,
                shading: THREE.FlatShading
            }));
            object.translateX(this.totalWidth / 2 * direction);
            object.rotation.z = -(90 * Math.PI / 180);
            scene.add(object);

            this.addToArray(group, object, values, direction);
        },

        addCone: function (values, direction) {
            this.moveObjects(values.width, direction); // Двигаем элементы в сторону
            // 2D
            var group = draw.group();
            group.add(draw.polygon(createPolyline(values, 0)).fill({
                color: colors[1]
            }));
            group.add(draw.polygon(createPolyline(values, borderWidth)).colorIt()).move(borderWidth, borderWidth);

            // Axis rendering
            group.add(draw.line(-axisPadding, values.radius1, values.width + axisPadding, values.radius1).dashIt(values.width));
            group.placeIt(this.totalWidth, direction, true);

            // 3D
            var object = new THREE.Mesh(new THREE.CylinderGeometry(values.radius2, values.radius1, values.width, this.segments), new THREE.MeshPhongMaterial({
                color: 0xF0F0F0,
                shading: THREE.FlatShading
            }));
            object.translateX(this.totalWidth / 2 * direction);
            object.rotation.z = -(90 * Math.PI / 180);
            scene.add(object);

            this.addToArray(group, object, values, direction)
        },

        addToArray: function (d2, d3, values, direction) {
            if (direction >= 0) {
                this.d2.push(d2);
                this.d3.push(d3);
                this.values.push(values);
            } else {
                this.d2.unshift(d2);
                this.d3.unshift(d3);
                this.values.unshift(values);
            }
            this.updateTotalWidth(values.width);
            render();
        },
        updateTotalWidth: function (inc) {
            this.totalWidth += inc;
        },
        moveObjects: function (width, direction) {
            $.each(this.d2, function (i, e) {
                e.dx((parseInt(width)) / 2 * -1 * direction)
            });
            $.each(this.d3, function (i, e) {
                e.translateY(parseInt(width) / 2 * -1 * direction)
            });
        }
    }

    SVG.extend(SVG.Element, {
        colorIt: function () {
            return this.fill(colors[0]);
        },
        dashIt: function (width) {
            return this.stroke({
                width: borderWidth / 2,
                color: '#e67e22',
                dasharray: getDashLength(width - borderWidth / 2) + ', 2, 2, 2'
            });
        },
        placeIt: function (total_width, direction, withAxisX, withAxisY) {
            withAxisX == null ? withAxisX = false : true;
            withAxisY == null ? withAxisY = false : true;
            this.cx(windowWidth / 2 + withAxisX * axisPadding).cy(windowWidth / 2 + withAxisY * axisPadding);
            this.dx(total_width * direction / 2);
            withAxisX || withAxisY ? this.front() : this.back();
            return this;
        }
    });

    // Инициализация 3D сцены технологией THREE.js
    // Выглядит оч круто

    function init3D() {
        // Camera, задаем параметры камеры сцены
        camera = new THREE.PerspectiveCamera(60, 1, 1, 1000);
        camera.position.set(10, 0, 500);

        scene = new THREE.Scene();

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Control, сообщаем программе как будем крутить сцену, кстати, пришлось заюзать сторонюю библиотек, вырванную из примеров THREE.js
        controls = new THREE.TrackballControls(camera, document.getElementById('modeling'));
        controls.panSpeed = 0.8;
        controls.addEventListener('change', render);

        // Lights, освещение сцены, их 3, но на самом деле 2, один на всякий случай, пусть будет
        var lights = [];
        lights[0] = new THREE.DirectionalLight(0xffffff, 0.99);
        lights[1] = new THREE.DirectionalLight(0xffffff, 0.99);
        lights[0].position.set(300, 200, 150);
        lights[1].position.set(-300, -200, -150);
        scene.add(lights[0]);
        scene.add(lights[1]);

        // renderer, рендерер для браузера, сообщаем какой технологией рендерить сцену, в нашем случае - WebGL, будет работать даже на мобилках
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xffffff);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize($('#modeling').width(), $('#modeling').width());
        $('#modeling').append(renderer.domElement);
        $(window).on('resize', function () {
            onWindowResize();
        });
        render();
    }

    // Функция из документации, шоб ресайзило сцену при ресайзе окна, но почему то все равно не работает
    function onWindowResize() {
        console.log('resize');
        camera.aspect = 1;
        camera.updateProjectionMatrix();
        renderer.setSize($('#modeling').width(), $('#modeling').width());
        controls.handleResize();
        render();
    }

    // Какая то хрень данная в документации, надо использовать шоб работало
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
    }

    // Обновляем 3D сцену
    function render() {
        renderer.render(scene, camera);
    }

    // Инициализируем 2D SVG поле
    function init2D() {
        draw = SVG('drawing').size($('#drawing').width(), $('#drawing').width());
    }

    // Находим использованное модальное окно на основе closest
    function getClosestModal(e) {
        return $(e).closest('.modal');
    }

    // Получаем значения из модального окна в объекте
    function getValuesFromModal(e) {
        var obj = new Object();
        getClosestModal(e).find('input').each(function () {
            obj[$(this).attr('name')] = parseInt($(this).val());
            //$(this).val('');
        });
        return obj;
    }

    function getDashLength(width) { //  Подбор длины штриха осевой под коффициент 6 - типо крутая САПР, как компасс
        var i = 1;
        var length = false;
        while (length > 16 || !length) {
            i++;
            length = ((width + 4 + axisPadding * 2) / i - 4);
        }
        return length;
    }

    function createPolyline(v, bW) {
        return [
            [bW, bW],
            [v.width - bW, v.radius1 - v.radius2 + bW],
            [v.width - bW, v.radius1 + v.radius2 - bW],
            [bW, v.radius1 * 2 - bW]
        ];
    }

    init2D();
    init3D();
    animate();

    $('.btn.accept').click(function () {
        getClosestModal(this).modal('hide'); // Закрываем модальное окно
        var values = getValuesFromModal(this); // Получаем данные из модального окна
        var action = getClosestModal(this).attr('id'); // Получаем че это вообще за модальное окно было
        $('.arrows').show(); // Показываем стрелочки
        $('.arrows button').click(function () { // вешаем событие на клик по стрелочке
            $('.arrows').hide(); // Скрываем стрелочки
            var direction = $(this).attr('direction') == 'right' ? 1 : -1; // Вычисляем направление
            switch (action) { // Тут понятно, выбираем действие/фигуру
                case 'cubeModal': // Кубик
                    objects.addCube(values, direction);
                    break;
                case 'cylinderModal': // Цилиндр
                    objects.addCylinder(values, direction);
                    break;
                case 'coneModal':
                    objects.addCone(values, direction);
                    break;
                case 'sphereModal':
                    objects.addSphere(values, direction);
                    break;
                default:
                    false;
            }
            $('.arrows button').unbind(); // Убиваем событие на стрелочки
        });
        if (objects.d2.length < 1) { // если создаем первый элемент,
            $('.arrows button:first-child').click(); // то кликаем на первую попавшуюся стрелочку программой,
        } // нахрена ее тыкать человеку
    });

    // Это блок, стреляющий из камеры лучом по фигуре
    $('canvas').click(function (event) {

        event.preventDefault();

        var offset = $('canvas').parent().offset();

        mouse.x = ((event.clientX - offset.left) / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -((event.clientY - offset.top) / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        var intersects = raycaster.intersectObjects(objects.d3);
        if (intersects.length > 0) {
            if (selected) {
                selected.material.color.setHex(0xffffff);
                selected = false;
            } else {
                selected = intersects[0].object;
                selected.material.color.setHex(0x3c9eff);
            }
        }

        render();
    });



</script>
</body>
</html>